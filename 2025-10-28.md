---
id: 2025-10-28
aliases: []
tags:
  - daily-notes
---

# Fw

Overview
Our firmware system runs in a pseudo multi-threaded way. Each thread can take over the CPU for a certain amount of time to ensure that each thread works independently. Among them, three threads are the main parts of our architecture: EthernetParse, Schedule Manager, and Step Manager.

To follow a recommended order, the following subpages are suggested. Firstly, we introduce the thread architecture of our system. Next, we start with the EthernetParse thread, which receives commands from the PC. Then, we cover the two most important threads, Schedule and Step Manager, which handle most of the tasks in our system. After these three parts, we dive deeper into the detailed flowchart. Lastly, we cover Data Sampling and Logging.

## Thread management
Threads Management
This page provides a brief introduction to the three main types of thread management. In our current firmware architecture, we use cooperative scheduling. The second part of the page lists all the threads in our current firmware architecture.

Scheduling Policies
Preemptive Scheduling

The operating system allows stopping the execution of the currently running process and allocating the CPU to some other process. The scheduler can preempt them at any time, based on some criteria such as deadlines, events, or time slices.

It interrupts applications and gives control to other processes outside the applicationâ€™s control.

The executing process in preemptive scheduling is interrupted in the middle of execution when higher priority one comes whereas.

Advantage: it can guarantee the responsiveness and timeliness of the system.

Disadvantage: it can introduce more overhead and complexity, such as context switching, synchronization, and resource sharing.

Round Robin Scheduling

The Round Robin scheduling algorithm is a special kind preemptive scheduling algorithm. 

It uses a concept of time slice or time quantum. The process at the beginning of the ready queue gets the chance to be executed first but only for the span of one-time quantum.

When a process is already in the CPU being executed it has a limited time quantum which it gets to execute within but if it cannot complete itself then it gets preempted.

Cooperative Scheduling

Cooperative scheduling is a technique that requires the tasks to cooperate or yield the CPU to the scheduler.

A context switch occurs only when the processes voluntarily yield control periodically or when idle or logically blocked to allow multiple applications to execute simultaneously.

Process scheduler never interrupts a process unexpectedly.

Advantage: it can reduce the overhead and complexity of the system, such as context switching, synchronization, and resource sharing.

Disadvantage: it can compromise the responsiveness and timeliness of the system, especially if some tasks are long-running, greedy, or buggy.

Thread Summary
No.

Tread Name

Scheduling Policy

1

LEDFunc::LEDFunc_Thread

osDelay(LED_QUICK_DELAY) || osDelay(LED_SLOW_DELAY)

2

UartParse::UartParse_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

3

Smart_Battery::Smart_Battery_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

4

PARA_WatchdogTask::PARA_WatchdogTask_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

5

MultMCUParse::MultMCUParse_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

6

ThirdPartyUDP::ThirdPartyUDP_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

7

EventsRetransmission::EventsBuffering_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

8

EthernetParse::EthernetParse_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

9

AssemblePack::AssemblePack_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

10

CANBusParse::CANBusParse_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

11

thirdParty::thirdParty_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

12

Step_Manager_task::Step_Manager_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

13

Schedule_Manager_task::Schedule_Manager_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

14

Sample_Pro::Sample_Pro_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

15

safety_check::safety_check_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

16

PULSE_MV_Task::PULSE_MV_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

17

PowerManage::PowerManage_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

18

PowerAdj::PowerAdj_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

19

OS_LogicProcess::OS_LogicProcess_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

20

MetaVariable_Task::MetaVariable_Thread

osThreadYield()

21

IndependentVoltageCtrl_task::IndependentVoltageCtrl_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

22

FanAdj_task::FanAdj_Thread

osThreadYield()

23

Check_Limit_Low_task::Check_Limit_Low_Thread

osDelay(20000); //20000*50us = 1s

24

Check_Limit8_task::Check_Limit8_Thread

osThreadYield()

25

Check_Limit4_task::Check_Limit4_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

26

Check_V_Limit_task::Check_V_Limit_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

27

CConfig::CConfig_Thread

osThreadYield()

28

PowerLostCheck::PowerLostCheck_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

29

RBT3X_DCDC_SYS_Control_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)

30

BuiltIn_64X_Base::Envir_Temp_Thread

osDelay(MAIN_Func::RTXOS_THREAD_DELAY_VALUE)


