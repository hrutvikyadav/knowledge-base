---
id: 2025-10-29
aliases: []
tags:
  - daily-notes
---

SMT32MP157D on  Master !? ❯ claude                                                                                                                    via C v11.4.0-gcc

╭─── Claude Code v2.0.28 ────────────────────────────────────────────────────────────────────────────────────────────╮
│                                     │ Tips for getting started                                                     │
│        Welcome back Hrutvik!        │ Run /install-github-app to tag @claude right from your Github issues and PRs │
│                                     │ ✔ Run /init to create a CLAUDE.md file with instructions for Claude          │
│               ▐▛███▜▌               │ ──────────────────────────────────────────────────────────────────────────── │
│              ▝▜█████▛▘              │ Recent activity                                                              │
│                ▘▘ ▝▝                │ No recent activity                                                           │
│                                     │                                                                              │
│       Sonnet 4.5 · Claude Pro       │                                                                              │
│   /home/hrutvik_/work/SMT32MP157D   │                                                                              │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

> Can you tell me what CMSIS api version this code uses?

● I'll help you find the CMSIS API version used in this codebase. Let me search for CMSIS version information in the firmware directories.

● Search(pattern: "CMSIS.*VERSION|__CM_CMSIS_VERSION", glob: "*.h", output_mode: "content")
  ⎿  Found 115 lines (ctrl+o to expand)

● Search(pattern: "**/cmsis_version.h")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/core_cm*.h")
  ⎿  Found 10 files (ctrl+o to expand)

● Perfect! I found the CMSIS version information. Let me read the main version file to confirm:

● Read(M4/ArbinA7_Linux/Drivers/CMSIS/Include/cmsis_version.h)
  ⎿  Read 40 lines

● Read(STM32H743_MITSX/COMMON_OS/CMSIS/cmsis_version.h)
  ⎿  Read 40 lines

● Based on the codebase, this project uses CMSIS version 5.3.0 (specifically V5.0.3 dated June 24, 2019).

  Here's the breakdown:

  CMSIS Core(M) Version

  Version 5.3.0 - defined in:
  - M4/ArbinA7_Linux/Drivers/CMSIS/Include/cmsis_version.h:35-36
  - STM32H743_MITSX/COMMON_OS/CMSIS/cmsis_version.h:35-36

  #define __CM_CMSIS_VERSION_MAIN  ( 5U)  /* Main version */
  #define __CM_CMSIS_VERSION_SUB   ( 3U)  /* Sub version */

  Additional CMSIS Components

  CMSIS-RTOS API v2.0.1 - used in both projects:
  - M4 with FreeRTOS: osCMSIS = 0x20001U
  - STM32H743 with RTX: osCMSIS = 0x20001U

  Device-specific CMSIS versions:
  - STM32MP1xx (Cortex-M4): CMSIS Device v1.6.0
  - STM32H7xx (Cortex-M7): CMSIS Device v1.7.0

  Both firmware projects (M4 and STM32H743) use the same CMSIS Core version 5.3.0, which is consistent across the codebase.

> /exit
  ⎿  Catch you later!

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
> 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  ? for shortcuts
SMT32MP157D on  Master !? ❯ claude                                                                                                         via C v11.4.0-gcc took 2m45s

╭─── Claude Code v2.0.28 ────────────────────────────────────────────────────────────────────────────────────────────╮
│                                     │ Tips for getting started                                                     │
│        Welcome back Hrutvik!        │ Run /install-github-app to tag @claude right from your Github issues and PRs │
│                                     │ ✔ Run /init to create a CLAUDE.md file with instructions for Claude          │
│               ▐▛███▜▌               │ ──────────────────────────────────────────────────────────────────────────── │
│              ▝▜█████▛▘              │ Recent activity                                                              │
│                ▘▘ ▝▝                │ No recent activity                                                           │
│                                     │                                                                              │
│       Sonnet 4.5 · Claude Pro       │                                                                              │
│   /home/hrutvik_/work/SMT32MP157D   │                                                                              │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

> Can you give me an overview on how the A7 user-space application works? I want to start contributing to the A7 project.

● I'll help you understand the A7 user-space application architecture. Let me explore the codebase to give you a comprehensive overview.

● Explore(Explore A7 application structure)
  ⎿  Done (32 tool uses · 76.6k tokens · 1m 58s)

● A7 User-Space Application Overview

  Based on my exploration, here's a comprehensive guide to the A7 application architecture:

  ---
  System Architecture

  The A7 application is a multi-threaded Linux user-space program (C++) running on the Cortex-A7 core. It coordinates battery testing operations by:
  - Communicating with the M4 real-time coprocessor via shared memory (OpenAMP)
  - Managing 64 test channels simultaneously
  - Handling TCP/UDP network protocols for PC communication
  - Controlling hardware via the M4 firmware

  ---
  Key Entry Point: main.cpp

  Location: A7/test/src/main.cpp

  The startup sequence:
  1. Semaphore initialization - Inter-thread synchronization
  2. Hardware init - FRAM, EEPROM, board config
  3. M4 firmware loading - Via Linux remoteproc framework
  4. Software init - Creates all threads and message queues
  5. Main loop - Sleeps (actual work done in spawned threads)

  ---
  Threading Model: 4-Level Hierarchy

  The application uses a sophisticated layered threading model with different priorities:

  | Level   | Cycle Time | Purpose            | Key Tasks                                         |
  |---------|------------|--------------------|---------------------------------------------------|
  | Level 0 | 0.5ms      | Highest priority   | Event retransmission                              |
  | Level 1 | 1ms        | Real-time critical | Sample processing, limit checking, step execution |
  | Level 2 | 10ms       | Standard tasks     | Schedule mgmt, CAN bus, safety checks             |
  | Level 3 | 100ms      | Low priority       | Full safety check, fan control, watchdog          |

  Plus specialized threads:
  - EthernetParse (priority 10): TCP/UDP communication
  - Report_Transmit (priority 45): Data reporting to PC
  - UDP_Receive (priority 10): UDP server
  - TaskCount (priority 15): Performance monitoring

  All threads bound to CPU 0/1 for optimal performance.

  ---
  Core Subsystems

  1. Data Management (Datamanager.cpp - 10,740 lines)

  - Maintains state for all 64 channels
  - Stores schedule, step, and sample data
  - Manages calibration and PID coefficients
  - Tracks metavariables (voltage, current, capacity)

  St_ChannelInfo ChannelInfo[MAXCHANNELNO];       // Per-channel state
  St_ChannelSchedule ChannelSchedule[MAXCHANNELNO]; // Active schedule
  ST_Metavariable MetaVariables[MAXCHANNELNO];    // Real-time variables

  2. Step Manager (StepManage.cpp - 9,460 lines - largest component)

  - Executes test steps (CC, CV, Rest, Pulse, etc.)
  - Manages step timing and transitions
  - Handles burst mode sampling
  - Calculates internal resistance (IR)

  3. Sample Processing (SampleProcess.cpp - 1,878 lines)

  - Requests ADC samples from M4 every 1ms
  - Applies calibration (offset + gain)
  - Implements sigma filtering (3-sigma outlier removal)
  - Supports multiple sampling priorities

  4. Safety System (SafeCheck.cpp - 2,442 lines)

  - Checks voltage/current/power limits every 1ms
  - Monitors temperature alarms
  - Generates safety events
  - Triggers emergency stops

  5. Ethernet Communication (EthernetParse.cpp - 603KB!)

  - TCP server (ports 5678/5679)
  - UDP server for configuration
  - Command parsing and dispatch
  - Data report assembly
  - Multi-unit cascade support

  6. Schedule Manager (ScheduleManage.cpp - 3,805 lines)

  - Parses test schedules from PC
  - Manages schedule state machine
  - Coordinates multi-cycle testing
  - Calculates progress and remaining time

  ---
  Communication Mechanisms

  A7 ↔ M4 Shared Memory

  Location: include/ShareMem.h

  #define SHARED_MEM_A7TOM4_ADDR  0x30050000  // A7→M4 commands (12KB)
  #define SHARED_MEM_M4TOA7_ADDR  0x30053000  // M4→A7 responses (12KB)

  // A7 writes control commands:
  typedef struct {
      unsigned char m_beLock;              // Lock flag
      unsigned long m_CurrentCode;         // DAC code for current
      unsigned long m_VoltageCode;         // DAC code for voltage
  } St_SM_Disposable;

  // M4 writes ADC samples:
  typedef struct {
      unsigned char m_beLock;
      unsigned long m_codeValue1;          // Current ADC code
      unsigned long m_codeValue2;          // Voltage ADC code
  } St_SM_BuiltinData;

  Message Queues

  Schedule_Manager_task::msgid = msgget(SCH_MSGKEY, IPC_CREAT|0666);
  Step_Manager_task::msgid = msgget(STEP_MSGKEY, IPC_CREAT|0666);
  safety_check::msgid = msgget(SAFETYCHECK_MSGKEY, IPC_CREAT|0666);

  Watchdog Communication

  External watchdog process monitors via message queue (type 9001):
  struct message {
      long mtype;  // 9001
      ST_WatchDogInfo data;  // Contains M4RunningStatus
  };

  ---
  Critical Data Flow

  Sample Data Flow (1ms cycle):

  M4 ADC → Shared Memory → Sample_Pro::DoWork() →
  → Sigma Filter → Check_Limit4_task → Metavariable updates

  Control Flow (10ms cycle):

  TCP Command → Schedule_Manager → Step_Manager →
  → thirdParty FSM → Shared Memory → M4 Hardware

  Safety Flow (1ms + 10ms + 100ms):

  Limit definitions → Check_Limit4_task (1ms) →
  → safety_check::DoMSGSafetyWork (10ms) →
  → safety_check::DoWork (100ms) → Emergency stop if needed

  ---
  Build System

  CMake-based with ARM cross-compiler:

  cd A7/test/build
  cmake ..
  make

  Compiler: arm-none-linux-gnueabihf-g++ v9.2Output: test executableDependencies:
  - libDoRPMSG.so (A7-M4 communication)
  - libsqlite3.so (database)
  - pthread (threading)

  ---
  Getting Started: Where to Contribute

  1. Add New Metavariables

  - Protocol: Protocols/SF_Hwf.h (line ~100+)
  - Calculation: IV_Tasks/Metavariable.cpp:747
  - Reporting: Ethernet/EthernetParse.cpp:99

  2. Modify Control Logic

  - Step execution: IV_Tasks/StepManage.cpp:9460 (largest file)
  - Channel FSM: IV_Tasks/ThirdParty.cpp
  - Safety limits: IV_Tasks/SafeCheck.cpp:2442

  3. Add Communication Features

  - TCP/UDP handling: Ethernet/EthernetParse.cpp:603KB
  - CAN bus: Ethernet/fdcan.cpp
  - Protocol defs: Protocols/SF_Hwf.h:311KB

  4. Hardware Integration

  - Device drivers: COMMON_OS/Ext_Devices/
  - M4 interface: include/ShareMem.h
  - Device setup: src/DeviceManage.cpp

  ---
  Important Patterns

  Thread Safety

  pthread_mutex_lock(&MainHardware::mutex);
  // ... critical section ...
  pthread_mutex_unlock(&MainHardware::mutex);

  Shared Memory Access

  m_beLock = 1;  // Set lock
  // ... update shared memory ...
  m_beLock = 0;  // Release lock

  Per-Channel Arrays

  ChannelInfo[channelNo].m_ucStatus = CHN_STATUS_OPEN;

  ---
  Directory Structure Quick Reference

  A7/test/
  ├── src/main.cpp              # Entry point (721-859: thread creation)
  ├── IV_Tasks/                 # Core battery testing logic (47KB source)
  │   ├── StepManage.cpp       # Step execution engine (9460 lines)
  │   ├── Datamanager.cpp      # Channel data management (10740 lines)
  │   ├── SafeCheck.cpp        # Safety system (2442 lines)
  │   └── SampleProcess.cpp    # ADC processing (1878 lines)
  ├── Ethernet/                 # Network communication
  │   └── EthernetParse.cpp    # TCP/UDP protocol (603KB)
  ├── Protocols/               # Protocol definitions
  │   └── SF_Hwf.h            # Main protocol (311KB)
  └── include/                 # Headers (70+ files)
      ├── ShareMem.h          # A7-M4 shared memory structures
      └── ScheduleDataDefine.h # Data structures

  ---
  Recent Development Areas (from commits)

  - QA-8192: IV channel sampling reliability
  - QA-8158: CAN bus offline detection
  - QA-7694: M0 redundant voltage alarms
  - QA-8261: Latest merged feature

  ---
  This should give you a solid foundation! The codebase is large but well-organized. Start by reading src/main.cpp:258-859 to see how everything initializes and
  threads are created, then dive into specific subsystems based on what you want to contribute to.

> Ok another question. When we say it is user space application targeted for the A7 cortex. Does that mean the A7 will be running embedded linux with custom drivers?

● Yes, exactly! Let me clarify the architecture for you:

● Search(pattern: "**/Sautorun.sh")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "**/*.ko")
  ⎿  Found 0 files

● Search(pattern: "**/devicetree/**")
  ⎿  Found 17 files (ctrl+o to expand)

● Read(Sautorun.sh)
  ⎿  Read 75 lines

● Read(M4/ArbinA7_Linux/CA7/DeviceTree/ArbinA7_Linux/kernel/stm32mp157d-arbina7_linux-mx.dts)
  ⎿  Read 100 lines

● Perfect! Yes, you're absolutely correct. Here's the complete picture:

  Yes - The A7 Runs Embedded Linux with Custom Kernel Modules

  The STM32MP157D is a heterogeneous MPU (Microprocessor Unit) with:
  - Cortex-A7 dual-core → Runs embedded Linux (OpenSTLinux/Yocto-based)
  - Cortex-M4 → Runs FreeRTOS (bare-metal firmware)

  ---
  Evidence from the Boot Script

  The Sautorun.sh startup script shows the Linux environment clearly:

  #!/bin/sh

  # Mount Linux debugfs
  mount -t debugfs none /sys/kernel/debug

  # Configure network interfaces (Linux networking stack)
  ifconfig eth0 up
  wpa_supplicant -D wext -iwlan0 -c/etc/wpa_supplicant.conf &
  udhcpc -i wlan0

  # Load custom kernel modules (drivers)
  modprobe gpioled.ko           # GPIO LED control driver
  modprobe Fan_A1.ko            # Fan controller #1
  modprobe Fan_A2.ko            # Fan controller #2
  modprobe Fan_A3.ko            # Fan controller #3
  modprobe Fan_A4.ko            # Fan controller #4
  modprobe GPIO_w.ko            # GPIO write interface
  modprobe GPIO_wi.ko           # GPIO write interface (alternative)
  modprobe P_off.ko             # Power off control
  modprobe P_off_ac.ko          # AC power off control
  modprobe Voltage_a.ko         # Voltage monitoring driver
  modprobe Temp_alarm.ko        # Temperature alarm driver

  # Load M4 firmware via Linux remoteproc framework
  rm /lib/firmware/ArbinA7_Linux_CM4.elf
  cp /home/data/CM4_LBTS_3D/ArbinA7_Linux_CM4.elf /lib/firmware

  # Start the A7 user-space application
  cd /home/arbin_user
  ./test &

  ---
  Custom Kernel Modules (Drivers)

  You have 10 custom kernel modules (.ko files) that provide hardware access:

  | Module                | Purpose                               |
  |-----------------------|---------------------------------------|
  | gpioled.ko            | GPIO LED control via /dev/gpioled     |
  | Fan_A1.ko - Fan_A4.ko | Four independent fan controllers      |
  | GPIO_w.ko, GPIO_wi.ko | GPIO write interfaces for digital I/O |
  | P_off.ko, P_off_ac.ko | Power management and shutdown control |
  | Voltage_a.ko          | Voltage monitoring interface          |
  | Temp_alarm.ko         | Temperature alarm monitoring          |

  These drivers expose hardware to user-space via /dev/ or /sys/ interfaces.

  ---
  Linux Kernel Framework: remoteproc

  The A7 uses the Linux remoteproc framework to manage the M4 coprocessor:

  From A7/test/src/main.cpp:169-172:
  // Load M4 firmware using Linux sysfs interface
  system("echo stop > /sys/class/remoteproc/remoteproc0/state");
  system("echo ArbinA7_Linux_CM4.elf > /sys/class/remoteproc/remoteproc0/firmware");
  system("echo start > /sys/class/remoteproc/remoteproc0/state");

  This is a standard Linux kernel subsystem for managing remote processors.

  ---
  Device Tree Configuration

  The Linux kernel uses a device tree (.dtb) to describe hardware:

  Location: M4/ArbinA7_Linux/CA7/DeviceTree/ArbinA7_Linux/kernel/stm32mp157d-arbina7_linux-mx.dts

  Key sections:
  - Memory regions for A7-M4 shared memory
  - OpenAMP mailbox configuration (mboxes = <&ipcc 0>, <&ipcc 1>)
  - Pin multiplexing for SPI, UART, GPIO
  - M4 resource allocation (reserved memory regions)

  Device tree example (lines 97-100):
  &m4_rproc{
      mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>;
      mbox-names = "vq0", "vq1", "shutdown";
      ...
  }

  The &ipcc (Inter-Processor Communication Controller) is the hardware mailbox for A7↔M4 signaling.

  ---
  Linux Distribution

  Based on the device tree header:
  model = "STMicroelectronics custom STM32CubeMX board -
           openstlinux-6.1-yocto-mickledore-mp1-v23.06.21";

  Distribution: OpenSTLinux 6.1 (Yocto Project - Mickledore release)Kernel Version: Linux 6.1.xBuild System: Yocto/OpenEmbedded

  ---
  Architecture Summary

  ┌─────────────────────────────────────────────────────────┐
  │  STM32MP157D Silicon                                     │
  │                                                          │
  │  ┌────────────────────────────┐  ┌──────────────────┐  │
  │  │  Cortex-A7 (Dual Core)      │  │  Cortex-M4       │  │
  │  │                             │  │                  │  │
  │  │  Linux Kernel 6.1           │  │  FreeRTOS        │  │
  │  │  ├─ Custom Drivers (.ko)    │  │  ├─ OpenAMP      │  │
  │  │  ├─ remoteproc framework    │◄─┼─►│  ├─ HAL       │  │
  │  │  ├─ OpenAMP/rpmsg           │  │  │  └─ Tasks     │  │
  │  │  └─ Device Tree (.dtb)      │  │  │               │  │
  │  │                             │  │  └─ Real-time HW  │  │
  │  │  User Space:                │  │     control       │  │
  │  │  └─ test (A7 app - C++)    │  │                  │  │
  │  └────────────────────────────┘  └──────────────────┘  │
  │                                                          │
  │         Shared Memory (SRAM3: 0x10050000)               │
  │         Hardware Mailbox (IPCC)                         │
  └─────────────────────────────────────────────────────────┘

  ---
  Key Takeaways

  1. Yes, A7 runs embedded Linux (OpenSTLinux 6.1 / Yocto)
  2. Yes, custom kernel drivers exist (10 .ko modules)
  3. User-space application (test) communicates with kernel via:
    - /dev/ device files (e.g., /dev/gpioled)
    - /sys/class/remoteproc/ for M4 control
    - Standard POSIX APIs (pthread, message queues, sockets)
  4. M4 coprocessor runs bare-metal FreeRTOS
  5. Communication between A7 and M4 uses:
    - Shared memory (directly mapped SRAM)
    - Mailbox interrupts (IPCC hardware)
    - OpenAMP/RPMsg framework (both Linux kernel side and M4 firmware side)

  So your A7 application is a standard Linux user-space program that happens to control real-time hardware indirectly through the M4 coprocessor!

> Ok now that we have established these things. Can you suggest me some man pages to read alongside exploring this codebase for example you talked about standard
posix apis, so technically I should be able to learn more with `man 3 pthreads`. SO tell me where can I find such valueable info!

● Excellent question! Here's a curated guide to the documentation you should read to understand this codebase:

  POSIX Threading & Synchronization

  # Threading basics
  man 7 pthreads              # Overview of POSIX threads
  man 3 pthread_create        # Creating threads
  man 3 pthread_mutex_lock    # Mutexes for synchronization
  man 3 pthread_setaffinity_np # CPU affinity (used in this code)
  man 3 pthread_attr_setschedparam # Thread scheduling priorities

  # Semaphores
  man 7 sem_overview          # Overview of semaphores
  man 3 sem_init              # Initialize semaphore
  man 3 sem_wait              # Wait on semaphore
  man 3 sem_post              # Post to semaphore

  # Time functions (critical for real-time)
  man 3 clock_gettime         # Get time (CLOCK_MONOTONIC used in code)
  man 2 clock_nanosleep       # High-precision sleep (ThreadLevel1 uses this)
  man 3 usleep                # Microsecond sleep (ThreadLevel2/3 use this)

  System V IPC (Message Queues)

  # Message queues (heavily used for inter-thread communication)
  man 7 sysvipc               # Overview of System V IPC
  man 2 msgget                # Create/access message queue
  man 2 msgsnd                # Send message to queue
  man 2 msgrcv                # Receive message from queue
  man 2 msgctl                # Control operations
  man 1 ipcs                  # List IPC resources (useful for debugging!)
  man 1 ipcrm                 # Remove IPC resources

  Tip: Run ipcs -q on your target board to see active message queues!

  Network Programming

  # Sockets (EthernetParse uses these extensively)
  man 7 socket                # Overview of sockets
  man 7 tcp                   # TCP protocol
  man 7 udp                   # UDP protocol
  man 2 socket                # Create socket
  man 2 bind                  # Bind to address
  man 2 listen                # Listen for connections
  man 2 accept                # Accept connection
  man 2 send                  # Send data
  man 2 recv                  # Receive data
  man 3 inet_pton             # Convert IP addresses
  man 7 ip                    # IP protocol details

  # Network interface configuration
  man 8 ifconfig              # Configure network interfaces (used in Sautorun.sh)

  Memory Management

  # Memory locking (prevents paging, critical for real-time)
  man 2 mlock                 # Lock memory pages
  man 2 mlockall              # Lock all pages (likely used in this code)
  man 2 munlock               # Unlock memory

  # Shared memory
  man 7 shm_overview          # Overview of shared memory
  man 2 mmap                  # Memory mapping
  man 2 munmap                # Unmap memory

  Linux Kernel Interfaces

  # sysfs (used for remoteproc control)
  man 5 sysfs                 # sysfs filesystem

  # Device files
  man 4 null                  # Device file basics
  man 1 mknod                 # Create device nodes

  # Kernel modules
  man 8 modprobe              # Load kernel modules
  man 8 insmod                # Insert kernel module
  man 8 rmmod                 # Remove kernel module
  man 8 lsmod                 # List loaded modules
  man 5 modules.dep           # Module dependencies

  STM32MP1-Specific Documentation

  Official ST Wiki (Essential!)

  https://wiki.st.com/stm32mpu/wiki/Main_Page

  Key pages to read:
  1. Getting Started:
     https://wiki.st.com/stm32mpu/wiki/Getting_started/STM32MP1_boards/STM32MP157x-DK2/Let's_start

  2. Linux Kernel:
     https://wiki.st.com/stm32mpu/wiki/Linux_kernel_overview

  3. Device Tree:
     https://wiki.st.com/stm32mpu/wiki/Device_tree_configuration

  4. Remoteproc Framework (A7↔M4 communication):
     https://wiki.st.com/stm32mpu/wiki/Linux_remoteproc_framework_overview
     ⭐ THIS IS CRITICAL FOR YOUR PROJECT

  5. RPMsg Framework:
     https://wiki.st.com/stm32mpu/wiki/RPMsg_framework_overview
     ⭐ ALSO CRITICAL

  6. OpenAMP:
     https://wiki.st.com/stm32mpu/wiki/OpenAMP_framework_overview

  7. How to Load M4 Firmware:
     https://wiki.st.com/stm32mpu/wiki/How_to_load_a_firmware_on_Cortex-M4_with_remoteproc

  8. Memory Mapping:
     https://wiki.st.com/stm32mpu/wiki/STM32MP15_RAM_mapping

  Linux Kernel Documentation

  # If you have kernel source on your dev machine:
  <kernel-source>/Documentation/remoteproc.txt
  <kernel-source>/Documentation/rpmsg.txt
  <kernel-source>/Documentation/devicetree/

  # Online:
  https://www.kernel.org/doc/html/latest/staging/remoteproc.html
  https://www.kernel.org/doc/html/latest/staging/rpmsg.html

  OpenAMP Documentation

  https://openamp.github.io/
  https://github.com/OpenAMP/open-amp/wiki

  Key concepts:
  - libmetal: Hardware abstraction
  - RPMsg: Messaging protocol
  - remoteproc: Resource management

  Real-Time Programming

  # Real-time scheduling
  man 7 sched                 # Overview of CPU scheduling
  man 2 sched_setscheduler    # Set scheduling policy
  man 2 sched_setaffinity     # Set CPU affinity
  man 7 time                  # Time overview

  # Process priorities
  man 2 nice                  # Change process priority
  man 2 getpriority           # Get priority

  Yocto/OpenEmbedded (Build System)

  Yocto Project Documentation:
  https://docs.yoctoproject.org/

  OpenSTLinux Distribution:
  https://wiki.st.com/stm32mpu/wiki/OpenSTLinux_distribution

  Mickledore Release (your version):
  https://docs.yoctoproject.org/4.2/

  Embedded Linux Books (Highly Recommended)

  1. "Linux System Programming" by Robert Love
    - Chapters 2-7 (File I/O, Buffering, Memory)
    - Chapter 8 (Memory Management)
    - Chapter 9-10 (Signals, Time)
  2. "The Linux Programming Interface" by Michael Kerrisk
    - Part 3: Threads
    - Part 6: System V IPC (Message Queues!)
    - Part 7: Sockets
  3. "Mastering Embedded Linux Programming" by Chris Simmonds
    - Chapter 11: Inter-process Communication
    - Chapter 13: Starting Up (init systems, startup scripts)
    - Chapter 14: Real-time Programming
  4. "Building Embedded Linux Systems" by Karim Yaghmour
    - Device drivers and kernel modules

  Debugging & Tracing Tools

  # System calls tracing
  man 1 strace                # Trace system calls (SUPER useful!)

  # Library call tracing
  man 1 ltrace                # Trace library calls

  # Process monitoring
  man 1 top                   # Process viewer
  man 1 ps                    # Process status
  man 1 pmap                  # Process memory map

  # IPC debugging
  man 1 ipcs                  # Show IPC facilities
  man 1 lsof                  # List open files (including sockets!)

  # Network debugging
  man 8 netstat               # Network statistics
  man 8 ss                    # Socket statistics (modern replacement)
  man 8 tcpdump               # Packet capture

  Quick Reference for This Codebase

  Here's what to read based on what you want to understand:

  | Code Area                                  | Man Pages                                        | External Docs                      |
  |--------------------------------------------|--------------------------------------------------|------------------------------------|
  | Thread creation in main.cpp:721-859        | man 3 pthread_createman 3 pthread_setaffinity_np | -                                  |
  | Message queues in main.cpp:271-288         | man 2 msggetman 2 msgsndman 2 msgrcv             | -                                  |
  | M4 firmware loading in main.cpp:169-172    | man 5 sysfs                                      | ST Wiki: remoteproc                |
  | Shared memory in ShareMem.h                | man 2 mmap                                       | ST Wiki: RAM mapping               |
  | Network communication in EthernetParse.cpp | man 7 socketman 7 tcp                            | -                                  |
  | Real-time sleep in ThreadLevel1            | man 2 clock_nanosleepman 3 clock_gettime         | -                                  |
  | Kernel modules in Sautorun.sh              | man 8 modprobe                                   | Linux Device Drivers book          |
  | Device tree                                | -                                                | ST Wiki: Device tree configuration |

  Pro Tips

  1. Man page sections matter!

  man 2 open     # Section 2: System calls
  man 3 printf   # Section 3: Library functions
  man 7 socket   # Section 7: Overviews, conventions, misc
  man 8 modprobe # Section 8: System administration

  2. Search man pages

  man -k pthread    # Search for "pthread" in all man pages
  apropos socket    # Same as above

  3. Online man pages (if not on target board)

  https://man7.org/linux/man-pages/
  https://linux.die.net/man/

  4. On your target board

  # View system info
  cat /proc/cpuinfo           # CPU info (should show A7 cores)
  cat /proc/meminfo           # Memory info
  cat /proc/interrupts        # Interrupts (look for IPCC!)

  # View remoteproc status
  cat /sys/class/remoteproc/remoteproc0/state
  cat /sys/kernel/debug/remoteproc/remoteproc0/trace0

  # View loaded modules
  lsmod | grep -E "Fan|gpio|Temp|Voltage"

  # View message queues
  ipcs -q

  # View running threads
  ps -eLf | grep test         # Show all threads of 'test' process

  Learning Path Suggestion

  1. Week 1: POSIX threads and synchronization
    - man 7 pthreads, man 3 pthread_mutex_lock
    - Trace through main.cpp thread creation
  2. Week 2: System V IPC (message queues)
    - man 7 sysvipc, man 2 msgget
    - Trace how Schedule_Manager_task receives messages
  3. Week 3: Network programming
    - man 7 socket, man 7 tcp
    - Trace through EthernetParse.cpp
  4. Week 4: STM32MP1 remoteproc/RPMsg
    - ST Wiki remoteproc pages
    - Understand A7↔M4 communication in ShareMem.h
  5. Week 5: Device tree and kernel modules
    - ST Wiki device tree
    - Read Sautorun.sh and understand module loading

  This should give you a solid foundation! Start with the man pages for the specific APIs you see in the code, then dive into the ST Wiki for STM32MP1-specific
  features.

> /exit
  ⎿  Goodbye!

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
> 
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  ? for shortcuts
SMT32MP157D on  Master !? ❯                                                                                                               via C v11.4.0-gcc took 25m21s

